{"mappings":"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","sources":["docs/index.js"],"sourcesContent":["/**\n * Prism: Lightweight, robust, elegant syntax highlighting\n *\n * @license MIT <https://opensource.org/licenses/MIT>\n * @author Lea Verou <https://lea.verou.me>\n *\n * Heavily modified by Alexey Raspopov\n */\n\nfunction encode(tokens) {\n  if (tokens instanceof Token) {\n    return new Token(tokens.type, encode(tokens.content), tokens.alias);\n  } else if (Array.isArray(tokens)) {\n    return tokens.map(encode);\n  } else {\n    return tokens\n      .replace(/&/g, \"&amp;\")\n      .replace(/</g, \"&lt;\")\n      .replace(/\\u00a0/g, \" \");\n  }\n}\n\nlet lang = /(?:^|\\s)lang(?:uage)?-([\\w-]+)(?=\\s|$)/i;\nfunction getLanguage(element) {\n  let match = lang.exec(element.className);\n  if (match) {\n    return match[1].toLowerCase();\n  }\n  return \"none\";\n}\n\nlet languages = {\n  clike: {\n    comment: [\n      {\n        pattern: /(^|[^\\\\])\\/\\*[\\s\\S]*?(?:\\*\\/|$)/,\n        lookbehind: true,\n        greedy: true,\n      },\n      {\n        pattern: /(^|[^\\\\:])\\/\\/.*/,\n        lookbehind: true,\n        greedy: true,\n      },\n    ],\n    string: {\n      pattern: /([\"'])(?:\\\\(?:\\r\\n|[\\s\\S])|(?!\\1)[^\\\\\\r\\n])*\\1/,\n      greedy: true,\n    },\n    \"class-name\": {\n      pattern:\n        /(\\b(?:class|extends|implements|instanceof|interface|new|trait)\\s+|\\bcatch\\s+\\()[\\w.\\\\]+/i,\n      lookbehind: true,\n      inside: {\n        punctuation: /[.\\\\]/,\n      },\n    },\n    keyword:\n      /\\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while|import|from|export|let|const)\\b/,\n    boolean: /\\b(?:false|true)\\b/,\n    function: /\\b\\w+(?=\\()/,\n    number: /\\b0x[\\da-f]+\\b|(?:\\b\\d+(?:\\.\\d*)?|\\B\\.\\d+)(?:e[+-]?\\d+)?/i,\n    operator: /[<>]=?|=>|[!=]=?=?|--?|\\+\\+?|&&?|\\|\\|?|[?*/~^%]/,\n    punctuation: /[{}[\\];(),.:]/,\n  },\n};\n\nfunction highlightAll() {\n  let elements = document.querySelectorAll('pre[class*=\"language-\"]');\n  for (let element of elements) {\n    let language = getLanguage(element);\n    let cursor = element.firstElementChild;\n    while (cursor != null) {\n      highlightElement(cursor, language);\n      cursor = cursor.nextElementSibling;\n    }\n  }\n}\n\nfunction highlightElement(element, language) {\n  let grammar = languages[language];\n\n  let code = element.textContent;\n  if (!code) return;\n\n  element.innerHTML = grammar ? highlight(code, grammar, language) : encode(code);\n}\n\nfunction highlight(text, grammar, language) {\n  let tokens = tokenize(text, grammar);\n  return stringify(encode(tokens), language);\n}\n\nfunction tokenize(text, grammar) {\n  var rest = grammar.rest;\n  if (rest) {\n    for (var token in rest) {\n      grammar[token] = rest[token];\n    }\n\n    delete grammar.rest;\n  }\n\n  var tokenList = new LinkedList();\n  addAfter(tokenList, tokenList.head, text);\n  matchGrammar(text, tokenList, grammar, tokenList.head, 0);\n  return toArray(tokenList);\n}\n\nfunction Token(type, content, alias, matchedStr) {\n  this.type = type;\n  this.content = content;\n  this.alias = alias;\n  this.length = (matchedStr || \"\").length | 0;\n}\n\nfunction stringify(o, language) {\n  if (typeof o == \"string\") {\n    return o;\n  }\n  if (Array.isArray(o)) {\n    var s = \"\";\n    o.forEach(function (e) {\n      s += stringify(e, language);\n    });\n    return s;\n  }\n\n  var env = {\n    type: o.type,\n    content: stringify(o.content, language),\n    tag: \"span\",\n    classes: [\"token\", o.type],\n    attributes: {},\n    language: language,\n  };\n\n  var aliases = o.alias;\n  if (aliases) {\n    if (Array.isArray(aliases)) {\n      Array.prototype.push.apply(env.classes, aliases);\n    } else {\n      env.classes.push(aliases);\n    }\n  }\n\n  var attributes = \"\";\n  for (var name in env.attributes) {\n    attributes += \" \" + name + '=\"' + (env.attributes[name] || \"\").replace(/\"/g, \"&quot;\") + '\"';\n  }\n\n  return (\n    \"<\" +\n    env.tag +\n    ' class=\"' +\n    env.classes.join(\" \") +\n    '\"' +\n    attributes +\n    \">\" +\n    env.content +\n    \"</\" +\n    env.tag +\n    \">\"\n  );\n}\n\nfunction matchPattern(pattern, pos, text, lookbehind) {\n  pattern.lastIndex = pos;\n  var match = pattern.exec(text);\n  if (match && lookbehind && match[1]) {\n    // change the match to remove the text matched by the Prism lookbehind group\n    var lookbehindLength = match[1].length;\n    match.index += lookbehindLength;\n    match[0] = match[0].slice(lookbehindLength);\n  }\n  return match;\n}\n\nfunction matchGrammar(text, tokenList, grammar, startNode, startPos, rematch) {\n  for (var token in grammar) {\n    if (!grammar.hasOwnProperty(token) || !grammar[token]) {\n      continue;\n    }\n\n    var patterns = grammar[token];\n    patterns = Array.isArray(patterns) ? patterns : [patterns];\n\n    for (var j = 0; j < patterns.length; ++j) {\n      if (rematch && rematch.cause == token + \",\" + j) {\n        return;\n      }\n\n      var patternObj = patterns[j];\n      var inside = patternObj.inside;\n      var lookbehind = !!patternObj.lookbehind;\n      var greedy = !!patternObj.greedy;\n      var alias = patternObj.alias;\n\n      if (greedy && !patternObj.pattern.global) {\n        // Without the global flag, lastIndex won't work\n        var flags = patternObj.pattern.toString().match(/[imsuy]*$/)[0];\n        patternObj.pattern = RegExp(patternObj.pattern.source, flags + \"g\");\n      }\n\n      /** @type {RegExp} */\n      var pattern = patternObj.pattern || patternObj;\n\n      for (\n        // iterate the token list and keep track of the current token/string position\n        var currentNode = startNode.next, pos = startPos;\n        currentNode !== tokenList.tail;\n        pos += currentNode.value.length, currentNode = currentNode.next\n      ) {\n        if (rematch && pos >= rematch.reach) {\n          break;\n        }\n\n        var str = currentNode.value;\n\n        if (tokenList.length > text.length) {\n          // Something went terribly wrong, ABORT, ABORT!\n          return;\n        }\n\n        if (str instanceof Token) {\n          continue;\n        }\n\n        var removeCount = 1; // this is the to parameter of removeBetween\n        var match;\n\n        if (greedy) {\n          match = matchPattern(pattern, pos, text, lookbehind);\n          if (!match || match.index >= text.length) {\n            break;\n          }\n\n          var from = match.index;\n          var to = match.index + match[0].length;\n          var p = pos;\n\n          // find the node that contains the match\n          p += currentNode.value.length;\n          while (from >= p) {\n            currentNode = currentNode.next;\n            p += currentNode.value.length;\n          }\n          // adjust pos (and p)\n          p -= currentNode.value.length;\n          pos = p;\n\n          // the current node is a Token, then the match starts inside another Token, which is invalid\n          if (currentNode.value instanceof Token) {\n            continue;\n          }\n\n          // find the last node which is affected by this match\n          for (\n            var k = currentNode;\n            k !== tokenList.tail && (p < to || typeof k.value === \"string\");\n            k = k.next\n          ) {\n            removeCount++;\n            p += k.value.length;\n          }\n          removeCount--;\n\n          // replace with the new match\n          str = text.slice(pos, p);\n          match.index -= pos;\n        } else {\n          match = matchPattern(pattern, 0, str, lookbehind);\n          if (!match) {\n            continue;\n          }\n        }\n\n        // eslint-disable-next-line no-redeclare\n        var from = match.index;\n        var matchStr = match[0];\n        var before = str.slice(0, from);\n        var after = str.slice(from + matchStr.length);\n\n        var reach = pos + str.length;\n        if (rematch && reach > rematch.reach) {\n          rematch.reach = reach;\n        }\n\n        var removeFrom = currentNode.prev;\n\n        if (before) {\n          removeFrom = addAfter(tokenList, removeFrom, before);\n          pos += before.length;\n        }\n\n        removeRange(tokenList, removeFrom, removeCount);\n\n        var wrapped = new Token(\n          token,\n          inside ? tokenize(matchStr, inside) : matchStr,\n          alias,\n          matchStr,\n        );\n        currentNode = addAfter(tokenList, removeFrom, wrapped);\n\n        if (after) {\n          addAfter(tokenList, currentNode, after);\n        }\n\n        if (removeCount > 1) {\n          // at least one Token object was removed, so we have to do some rematching\n          // this can only happen if the current pattern is greedy\n\n          /** @type {RematchOptions} */\n          var nestedRematch = {\n            cause: token + \",\" + j,\n            reach: reach,\n          };\n          matchGrammar(text, tokenList, grammar, currentNode.prev, pos, nestedRematch);\n\n          // the reach might have been extended because of the rematching\n          if (rematch && nestedRematch.reach > rematch.reach) {\n            rematch.reach = nestedRematch.reach;\n          }\n        }\n      }\n    }\n  }\n}\n\nfunction LinkedList() {\n  var head = { value: null, prev: null, next: null };\n  var tail = { value: null, prev: head, next: null };\n  head.next = tail;\n\n  this.head = head;\n  this.tail = tail;\n  this.length = 0;\n}\n\nfunction addAfter(list, node, value) {\n  // assumes that node != list.tail && values.length >= 0\n  var next = node.next;\n\n  var newNode = { value: value, prev: node, next: next };\n  node.next = newNode;\n  next.prev = newNode;\n  list.length++;\n\n  return newNode;\n}\n\nfunction removeRange(list, node, count) {\n  var next = node.next;\n  for (var i = 0; i < count && next !== list.tail; i++) {\n    next = next.next;\n  }\n  node.next = next;\n  next.prev = node;\n  list.length -= i;\n}\n\nfunction toArray(list) {\n  let array = [];\n  let node = list.head.next;\n  while (node !== list.tail) {\n    array.push(node.value);\n    node = node.next;\n  }\n  return array;\n}\n\nlet readyState = document.readyState;\nif (document.readyState === \"loading\") {\n  document.addEventListener(\"DOMContentLoaded\", () => highlightAll());\n} else {\n  window.requestAnimationFrame(() => highlightAll());\n}\n"],"names":["encode","tokens","Token","type","content","alias","Array","isArray","map","replace","lang","getLanguage","element","match","exec","className","toLowerCase","languages","clike","comment","pattern","lookbehind","greedy","string","inside","punctuation","keyword","boolean","function","number","operator","highlightAll","elements","document","querySelectorAll","language","cursor","firstElementChild","highlightElement","nextElementSibling","grammar","code","textContent","innerHTML","highlight","text","stringify","tokenize","rest","token","tokenList","LinkedList","addAfter","head","matchGrammar","toArray","matchedStr","this","length","o","s","forEach","e","env","tag","classes","attributes","aliases","prototype","push","apply","name","join","matchPattern","pos","lastIndex","lookbehindLength","index","slice","startNode","startPos","rematch","hasOwnProperty","patterns","j","cause","patternObj","global","flags","toString","RegExp","source","currentNode","next","tail","reach","value","str","removeCount","from","to","p","k","matchStr","before","after","removeFrom","prev","removeRange","nestedRematch","list","node","newNode","count","i","array","readyState","addEventListener","window","requestAnimationFrame"],"version":3,"file":"index.6047b0c5.js.map"}